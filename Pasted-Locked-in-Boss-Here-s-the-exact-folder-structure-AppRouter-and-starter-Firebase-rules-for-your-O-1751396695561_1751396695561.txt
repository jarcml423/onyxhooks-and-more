Locked in, Boss. Here’s the exact folder structure, AppRouter, and starter Firebase rules for your OfferForge admin system in Replit.

✅ Folder Structure
plaintext
Copy
Edit
offerforge-admin/
├── public/
│   └── index.html
├── src/
│   ├── assets/
│   ├── components/
│   │   ├── DashboardCard.jsx
│   │   ├── TierLock.jsx
│   │   ├── UserListTable.jsx
│   ├── context/
│   │   └── AuthContext.jsx
│   ├── hooks/
│   │   └── useSubscriptionStatus.js
│   ├── pages/
│   │   ├── AdminDashboard.jsx
│   │   ├── BillingError.jsx
│   │   ├── Login.jsx
│   │   ├── NotFound.jsx
│   ├── routes/
│   │   └── AppRouter.jsx
│   ├── services/
│   │   ├── firebase.js
│   │   ├── stripeWebhookHandler.js
│   ├── App.jsx
│   └── main.jsx
├── functions/
│   ├── index.js         ← Stripe Webhook (Firebase Function)
│   └── .runtimeconfig.json
├── .env
├── firebase.json
├── firestore.rules
├── tailwind.config.js
├── postcss.config.js
├── package.json
🧭 AppRouter.jsx
jsx
Copy
Edit
import { Routes, Route, Navigate } from "react-router-dom";
import AdminDashboard from "../pages/AdminDashboard";
import BillingError from "../pages/BillingError";
import Login from "../pages/Login";
import NotFound from "../pages/NotFound";
import { useAuth } from "../context/AuthContext";

export default function AppRouter() {
  const { user, accessGranted } = useAuth();

  return (
    <Routes>
      <Route path="/" element={<Navigate to="/dashboard" />} />
      <Route path="/login" element={<Login />} />
      <Route
        path="/dashboard"
        element={
          user && accessGranted ? (
            <AdminDashboard />
          ) : (
            <Navigate to="/billing-error" />
          )
        }
      />
      <Route path="/billing-error" element={<BillingError />} />
      <Route path="*" element={<NotFound />} />
    </Routes>
  );
}
🔐 firestore.rules (for Firebase access control)
plaintext
Copy
Edit
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    match /Users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Restrict access to premium content
    match /PremiumFeatures/{docId} {
      allow read: if request.auth != null &&
        get(/databases/$(database)/documents/Users/$(request.auth.uid)).data.accessGranted == true;
    }

    // Admin-level dashboard queries
    match /AdminDashboard/{docId} {
      allow read: if request.auth != null && request.auth.token.admin == true;
    }
  }
}
🔧 Tip: Use custom claims to set admin: true via the Firebase Admin SDK.

⚡ Firebase Emulator Config (firebase.json)
json
Copy
Edit
{
  "emulators": {
    "auth": { "port": 9099 },
    "firestore": { "port": 8080 },
    "functions": { "port": 5001 }
  },
  "firestore": {
    "rules": "firestore.rules"
  }
}
🔁 Stripe Webhook Function (functions/index.js)
js
Copy
Edit
const functions = require("firebase-functions");
const admin = require("firebase-admin");
const stripe = require("stripe")(process.env.STRIPE_SECRET_KEY);
admin.initializeApp();

exports.handleStripeWebhook = functions.https.onRequest(async (req, res) => {
  const sig = req.headers["stripe-signature"];
  const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET;

  let event;
  try {
    event = stripe.webhooks.constructEvent(req.rawBody, sig, endpointSecret);
  } catch (err) {
    console.error("Webhook Error:", err.message);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  const session = event.data.object;

  switch (event.type) {
    case "checkout.session.completed":
      await admin.firestore().doc(`/Users/${session.client_reference_id}`).set({
        subscriptionStatus: "active",
        accessGranted: true,
        tier: session.metadata.tier,
        signupDate: admin.firestore.Timestamp.now(),
        paymentHistory: admin.firestore.FieldValue.arrayUnion({
          amount: session.amount_total / 100,
          date: admin.firestore.Timestamp.now(),
          tier: session.metadata.tier,
        }),
      }, { merge: true });
      break;

    case "customer.subscription.deleted":
    case "invoice.payment_failed":
      await admin.firestore().doc(`/Users/${session.client_reference_id}`).update({
        subscriptionStatus: "canceled",
        accessGranted: false,
      });
      break;

    default:
      console.log(`Unhandled event type ${event.type}`);
  }

  res.send({ received: true });
});