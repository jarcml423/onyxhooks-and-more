Locked in, Boss. Hereâ€™s the exact folder structure, AppRouter, and starter Firebase rules for your OfferForge admin system in Replit.

âœ… Folder Structure
plaintext
Copy
Edit
offerforge-admin/
â”œâ”€â”€ public/
â”‚   â””â”€â”€ index.html
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ assets/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ DashboardCard.jsx
â”‚   â”‚   â”œâ”€â”€ TierLock.jsx
â”‚   â”‚   â”œâ”€â”€ UserListTable.jsx
â”‚   â”œâ”€â”€ context/
â”‚   â”‚   â””â”€â”€ AuthContext.jsx
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â””â”€â”€ useSubscriptionStatus.js
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ AdminDashboard.jsx
â”‚   â”‚   â”œâ”€â”€ BillingError.jsx
â”‚   â”‚   â”œâ”€â”€ Login.jsx
â”‚   â”‚   â”œâ”€â”€ NotFound.jsx
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â””â”€â”€ AppRouter.jsx
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ firebase.js
â”‚   â”‚   â”œâ”€â”€ stripeWebhookHandler.js
â”‚   â”œâ”€â”€ App.jsx
â”‚   â””â”€â”€ main.jsx
â”œâ”€â”€ functions/
â”‚   â”œâ”€â”€ index.js         â† Stripe Webhook (Firebase Function)
â”‚   â””â”€â”€ .runtimeconfig.json
â”œâ”€â”€ .env
â”œâ”€â”€ firebase.json
â”œâ”€â”€ firestore.rules
â”œâ”€â”€ tailwind.config.js
â”œâ”€â”€ postcss.config.js
â”œâ”€â”€ package.json
ğŸ§­ AppRouter.jsx
jsx
Copy
Edit
import { Routes, Route, Navigate } from "react-router-dom";
import AdminDashboard from "../pages/AdminDashboard";
import BillingError from "../pages/BillingError";
import Login from "../pages/Login";
import NotFound from "../pages/NotFound";
import { useAuth } from "../context/AuthContext";

export default function AppRouter() {
  const { user, accessGranted } = useAuth();

  return (
    <Routes>
      <Route path="/" element={<Navigate to="/dashboard" />} />
      <Route path="/login" element={<Login />} />
      <Route
        path="/dashboard"
        element={
          user && accessGranted ? (
            <AdminDashboard />
          ) : (
            <Navigate to="/billing-error" />
          )
        }
      />
      <Route path="/billing-error" element={<BillingError />} />
      <Route path="*" element={<NotFound />} />
    </Routes>
  );
}
ğŸ” firestore.rules (for Firebase access control)
plaintext
Copy
Edit
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    match /Users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Restrict access to premium content
    match /PremiumFeatures/{docId} {
      allow read: if request.auth != null &&
        get(/databases/$(database)/documents/Users/$(request.auth.uid)).data.accessGranted == true;
    }

    // Admin-level dashboard queries
    match /AdminDashboard/{docId} {
      allow read: if request.auth != null && request.auth.token.admin == true;
    }
  }
}
ğŸ”§ Tip: Use custom claims to set admin: true via the Firebase Admin SDK.

âš¡ Firebase Emulator Config (firebase.json)
json
Copy
Edit
{
  "emulators": {
    "auth": { "port": 9099 },
    "firestore": { "port": 8080 },
    "functions": { "port": 5001 }
  },
  "firestore": {
    "rules": "firestore.rules"
  }
}
ğŸ” Stripe Webhook Function (functions/index.js)
js
Copy
Edit
const functions = require("firebase-functions");
const admin = require("firebase-admin");
const stripe = require("stripe")(process.env.STRIPE_SECRET_KEY);
admin.initializeApp();

exports.handleStripeWebhook = functions.https.onRequest(async (req, res) => {
  const sig = req.headers["stripe-signature"];
  const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET;

  let event;
  try {
    event = stripe.webhooks.constructEvent(req.rawBody, sig, endpointSecret);
  } catch (err) {
    console.error("Webhook Error:", err.message);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  const session = event.data.object;

  switch (event.type) {
    case "checkout.session.completed":
      await admin.firestore().doc(`/Users/${session.client_reference_id}`).set({
        subscriptionStatus: "active",
        accessGranted: true,
        tier: session.metadata.tier,
        signupDate: admin.firestore.Timestamp.now(),
        paymentHistory: admin.firestore.FieldValue.arrayUnion({
          amount: session.amount_total / 100,
          date: admin.firestore.Timestamp.now(),
          tier: session.metadata.tier,
        }),
      }, { merge: true });
      break;

    case "customer.subscription.deleted":
    case "invoice.payment_failed":
      await admin.firestore().doc(`/Users/${session.client_reference_id}`).update({
        subscriptionStatus: "canceled",
        accessGranted: false,
      });
      break;

    default:
      console.log(`Unhandled event type ${event.type}`);
  }

  res.send({ received: true });
});